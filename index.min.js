'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Image Sequencer for ScrollMagic Scene
 * (c) 2018
 *
 * Author:
 *      Ilya Kiselev
 *      ikiselev1989@gmail.com
 *
 * Project:
 *      https://github.com/ikiselev1989/scrollmagic-image-sequencer-plugin
 *
 * Version: 2.4.0
 *
 * Based on http://github.com/ertdfgcvb/Sequencer
 */

String.prototype.repeat = String.prototype.repeat || function (n) {
    return n <= 1 ? this : this + this.repeat(n - 1);
};

function padLeft(str, char, length) {
    return char.repeat(Math.max(0, length - str.length)) + str;
}

var Sequencer = function () {
    function Sequencer(opts) {
        _classCallCheck(this, Sequencer);

        var defaults = {
            canvas: null,
            from: '',
            to: '',
            scaleMode: 'cover', // can be: auto, cover, contain
            hiDPI: true,
            asyncLoader: false,
            initFrameDraw: true,
            scrollEasing: 500,
            totalLoadCallback: null,
            imageLoadCallback: null
        };

        this._config = Object.assign({}, defaults, opts);

        // backwards compatibility: .retina field is assigned to .hiDPI (Retina is an Apple trademark)
        if (opts.hasOwnProperty('retina')) this._config.hiDPI = opts.retina;

        if (this._config.from == '' && this._config.to == '') {
            console.error('Missing filenames.');
            return false;
        }

        if (!this._config.canvas) {
            console.error('Missing canvas node.');
            return false;
        }

        this._stoped = false;
        this._direction = 'PAUSED';
        this._loadedImages = 0;
        this._totalLoaded = false;
        this._frameCountFactor = 1;

        this._asyncPreloaderList = [];

        this._currentFrame = 0;
        this._images = [];
        this._ctx = this._config.canvas.getContext('2d');

        var _sequenceParser = this._parseSequence(this._config.from, this._config.to);
        this._fileList = this._buildFileList(_sequenceParser);

        this._size(this._ctx.canvas.width, this._ctx.canvas.height);

        this._load();
    }

    _createClass(Sequencer, [{
        key: '_load',
        value: function _load() {
            if (!this._config.asyncLoader) {
                this._preloader();
            }
        }
    }, {
        key: '_setDrawLoop',
        value: function _setDrawLoop(currentFrame, direction) {
            this._clearDrawLoop();

            if (this._stoped) {
                return this._currentFrame = currentFrame;
            }
            if (!this._config.asyncLoader && !this._totalLoaded) return;

            this._direction = direction;

            var scrollEasing = this._config.scrollEasing;


            var now = performance.now();
            var timeLaps = 0;

            this._drawLoop = requestAnimationFrame(function loop(time) {
                var timeDelta = Math.floor(time - now);
                var frameCount = Math.abs(this._currentFrame - currentFrame);
                var frameCountFactor = Math.round(frameCount / (scrollEasing / timeDelta));

                this._frameCountFactor = frameCountFactor < 1 ? 1 : frameCountFactor;

                timeLaps = timeDelta / (frameCount / this._frameCountFactor * timeDelta);

                this._setCurrentFrameByDirection(this._frameCountFactor);
                this._loaderMethodChecker();

                if (timeLaps < 1) {
                    this._drawLoop = requestAnimationFrame(loop.bind(this));
                }
            }.bind(this));
        }
    }, {
        key: '_clearDrawLoop',
        value: function _clearDrawLoop() {
            cancelAnimationFrame(this._drawLoop);
        }
    }, {
        key: '_setCurrentFrameByDirection',
        value: function _setCurrentFrameByDirection() {
            var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

            if (this._direction === 'FORWARD') this._currentFrame += factor;
            if (this._direction === 'REVERSE') this._currentFrame -= factor;
            if (this._direction != 'PAUSED') this._config.initFrameDraw = true;

            var imagesCount = this._fileList.length - 1;
            this._currentFrame = this._currentFrame < 0 ? 0 : this._currentFrame > imagesCount ? imagesCount : this._currentFrame;
        }
    }, {
        key: '_loaderMethodChecker',
        value: function _loaderMethodChecker() {
            this._config.asyncLoader && this._asyncLoadedChecker();
            !this._config.asyncLoader && this._drawImage();
        }
    }, {
        key: '_asyncLoadedChecker',
        value: function _asyncLoadedChecker() {
            var image = this._images[this._currentFrame];

            if (!this._config.initFrameDraw) {
                this._frameLoader(this._currentFrame);
            } else {
                image && image.loaded && this._drawImage();
                !image && this._frameLoader(this._currentFrame);

                if (!this._totalLoaded) {
                    this._asyncPreloader();
                }
            }
        }
    }, {
        key: '_frameLoader',
        value: function _frameLoader(targetFrame) {
            var _this = this;

            if (this._images[targetFrame]) return;

            var img = new Image();

            img.onload = function () {
                img.loaded = true;

                _this._loadedImages++;

                _this._config.asyncLoader && _this._config.initFrameDraw && _this._currentFrame === targetFrame && _this._drawImage();
                _this._config.imageLoadCallback && _this._config.imageLoadCallback({ img: img, frame: targetFrame });

                if (_this._loadedImages === _this._fileList.length) {
                    _this._loadedImagesCallback();
                }
            };

            img.onerror = function () {
                console.error('Error with image-id: ' + targetFrame);
            };

            this._images[targetFrame] = img;

            img.src = this._fileList[targetFrame];
        }
    }, {
        key: '_asyncPreloader',
        value: function _asyncPreloader() {
            var _this2 = this;

            var preloadFrames = 5;
            var framesList = [];

            clearInterval(this._asyncPreloadInterval);

            for (var iter = 1; iter < preloadFrames; iter++) {
                if (this._currentFrame === 0) {
                    this._direction = 'FORWARD';
                }
                if (this._currentFrame === this._fileList.length - 1) {
                    this._direction = 'REVERSE';
                }

                var preloadFrame = this._direction === 'REVERSE' ? this._currentFrame - iter : this._currentFrame + iter;

                if (preloadFrame < 0 || preloadFrame >= this._fileList.length) {
                    return;
                }

                framesList.push(preloadFrame);
            }

            this._asyncPreloaderList = [].concat(framesList, _toConsumableArray(this._asyncPreloaderList));

            this._asyncPreloadInterval = setInterval(function () {
                var image = _this2._asyncPreloaderList.shift();

                if (!image) {
                    return clearInterval(_this2._asyncPreloadInterval);
                }

                _this2._frameLoader(image);
            }, 33.3);
        }
    }, {
        key: '_preloader',
        value: function _preloader() {
            for (var iter = 0; iter < this._fileList.length; iter++) {
                this._frameLoader(iter);
            }
        }
    }, {
        key: '_loadedImagesCallback',
        value: function _loadedImagesCallback() {
            this._totalLoaded = true;
            this._config.totalLoadCallback && this._config.totalLoadCallback();

            if (this._config.initFrameDraw) {
                this._drawImage();
            }
        }
    }, {
        key: '_drawImage',
        value: function _drawImage() {
            requestAnimationFrame(this._canvasDraw.bind(this));
        }
    }, {
        key: '_canvasDraw',
        value: function _canvasDraw() {
            var img = this._images[this._currentFrame];

            if (!img || !img.loaded || this._currentDrawFrame === this._currentFrame) return;

            var r = this._config.hiDPI ? window.devicePixelRatio : 1;
            var cw = this._ctx.canvas.width / r;
            var ch = this._ctx.canvas.height / r;
            var ca = cw / ch;
            var ia = img.width / img.height;
            var iw = void 0,
                ih = void 0;

            if (this._config.scaleMode == 'cover') {
                if (ca > ia) {
                    iw = cw;
                    ih = iw / ia;
                } else {
                    ih = ch;
                    iw = ih * ia;
                }
            } else if (this._config.scaleMode == 'contain') {
                if (ca < ia) {
                    iw = cw;
                    ih = iw / ia;
                } else {
                    ih = ch;
                    iw = ih * ia;
                }
            } else {
                //this._config.scaleMode == 'auto'
                iw = img.width;
                ih = img.height;
            }

            var ox = cw / 2 - iw / 2;
            var oy = ch / 2 - ih / 2;

            this._ctx.save();
            this._ctx.scale(r, r);
            this._ctx.clearRect(0, 0, cw, ch); // support for images with alpha
            this._ctx.drawImage(img, 0, 0, img.width, img.height, ~~ox, ~~oy, ~~iw, ~~ih);
            this._ctx.restore();

            this._currentDrawFrame = this._currentFrame;
        }
    }, {
        key: '_size',
        value: function _size(w, h) {
            var r = this._config.hiDPI ? window.devicePixelRatio : 1;
            var c = this._ctx.canvas;
            c.width = w * r;
            c.height = h * r;
            c.style.width = w + 'px';
            c.style.height = h + 'px';
        }
    }, {
        key: '_parseSequence',
        value: function _parseSequence(from, to) {
            var l = Math.min(from.length, to.length);
            var i = Math.max(0, from.lastIndexOf('/'));

            while (from.charAt(i) == to.charAt(i) && !/[1-9]/.test(from.charAt(i)) && i < l) {
                i++;
            }var a = from.slice(i, from.lastIndexOf('.')); // from, may contain leading zeros
            var b = to.slice(i, to.lastIndexOf('.')); // to
            var ia = parseInt(a);
            var ib = parseInt(b);

            return {
                from: ia,
                to: ib,
                base: from.substr(0, i),
                ext: from.substr(from.lastIndexOf('.')),
                zeroes: a.length == b.length && Math.floor(log10(ia)) < Math.floor(log10(ib)) ? a.length : 0,
                length: Math.abs(ib - ia) + 1
            };

            function log10(x) {
                return Math.log(x) / Math.LN10;
            }
        }
    }, {
        key: '_buildFileList',
        value: function _buildFileList(sequenceObj) {
            var q = [];
            var dir = sequenceObj.from > sequenceObj.to ? -1 : 1;
            for (var i = 0; i < sequenceObj.length; i++) {
                var n = (sequenceObj.from + i * dir).toString();
                var num = padLeft(n, '0', sequenceObj.zeroes);
                q.push(sequenceObj.base + num + sequenceObj.ext);
            }
            return q;
        }
    }, {
        key: 'resumeDrawing',
        value: function resumeDrawing() {
            this._stoped = false;
        }
    }, {
        key: 'stopDrawing',
        value: function stopDrawing() {
            this._stoped = true;
            this._clearDrawLoop();
        }
    }]);

    return Sequencer;
}();

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['ScrollMagic'], factory);
    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
        // CommonJS
        factory(require('scrollmagic'));
    } else {
        // no browser global export needed, just execute
        factory(root.ScrollMagic || root.jQuery && root.jQuery.ScrollMagic);
    }
})(undefined, function (ScrollMagic) {
    // 'window' change to 'this'
    ScrollMagic.Scene.prototype.addImageSequencer = function (opt) {
        var sequencer = new Sequencer(opt);

        this.on('progress', function (_ref) {
            var progress = _ref.progress,
                scrollDirection = _ref.scrollDirection;

            var currentFrame = Math.round(progress * (sequencer._fileList.length - 1));
            sequencer._setDrawLoop(currentFrame, scrollDirection);
        });

        return sequencer;
    };
});
