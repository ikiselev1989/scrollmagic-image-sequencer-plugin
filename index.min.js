'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Image Sequencer for ScrollMagic Scene
 * (c) 2018
 *
 * Author:
 *      Ilya Kiselev
 *      ikiselev1989@gmail.com
 *
 * Project:
 *      https://github.com/ikiselev1989/scrollmagic-image-sequencer-plugin
 *
 * Version: 1.6.0
 *
 * Based on http://github.com/ertdfgcvb/Sequencer
 */

String.prototype.repeat = String.prototype.repeat || function (n) {
    return n <= 1 ? this : this + this.repeat(n - 1);
};

function padLeft(str, char, length) {
    return char.repeat(Math.max(0, length - str.length)) + str;
}

var Sequencer = function () {
    function Sequencer(opts) {
        _classCallCheck(this, Sequencer);

        var defaults = {
            canvas: null,
            from: '',
            to: '',
            scaleMode: 'cover', // can be: auto, cover, contain
            hiDPI: true,
            progressiveLoader: false,
            preloadFrameCount: 30,
            smoothFrameChange: false, // like a movie
            fps: 60
        };

        this.config = Object.assign({}, defaults, opts);

        // backwards compatibility: .retina field is assigned to .hiDPI (Retina is an Apple trademark)
        if (opts.hasOwnProperty('retina')) this.config.hiDPI = opts.retina;

        if (this.config.from == '' && this.config.to == '') {
            console.error('Missing filenames.');
            return false;
        }

        if (!this.config.canvas) {
            console.error('Missing canvas node.');
            return false;
        }

        this.currentFrame = 0;
        this.images = [];
        this.ctx = this.config.canvas.getContext('2d');

        var s = this.parseSequence(this.config.from, this.config.to);
        this.fileList = this.buildFileList(s);

        this.size(this.ctx.canvas.width, this.ctx.canvas.height);

        this.load();
    }

    _createClass(Sequencer, [{
        key: 'load',
        value: function load() {
            this.load = function () {
                console.log('load() can be called only once.');
            };

            if (!this.config.progressiveLoader) {
                this.preloader();
            } else {
                var _config = this.config,
                    smoothFrameChange = _config.smoothFrameChange,
                    preloadFrameCount = _config.preloadFrameCount,
                    fps = _config.fps;


                this.frameLoader(0, true);

                var preloadFrames = smoothFrameChange ? fps * 2 : preloadFrameCount;

                for (var i = -preloadFrames; i < preloadFrames; i++) {
                    this.frameLoader(i);
                }
            }
        }
    }, {
        key: 'updateFrame',
        value: function updateFrame(reqFrame) {
            var smoothFrameChange = this.config.smoothFrameChange;


            smoothFrameChange && this.setInterval(reqFrame);
            !smoothFrameChange && this.scrollDrawImage(reqFrame);
        }
    }, {
        key: 'setInterval',
        value: function (_setInterval) {
            function setInterval(_x) {
                return _setInterval.apply(this, arguments);
            }

            setInterval.toString = function () {
                return _setInterval.toString();
            };

            return setInterval;
        }(function (reqFrame) {
            var _this = this;

            var iter = Math.abs(Number(this.currentFrame) - Number(reqFrame));

            clearInterval(this.interval);

            if (iter > 0 && iter <= this.config.fps) {
                var direction = this.currentFrame > reqFrame ? 'prev' : 'next';

                this.interval = setInterval(function () {
                    var frame = direction === 'next' ? _this.currentFrame += 1 : _this.currentFrame -= 1;

                    requestAnimationFrame(function () {
                        _this.scrollDrawImage(frame);

                        iter--;
                        if (iter <= 0) clearInterval(_this.interval);
                    });
                }, 1000 / this.config.fps);
            } else {
                this.scrollDrawImage(reqFrame);
            }
        })
    }, {
        key: 'scrollDrawImage',
        value: function scrollDrawImage(frame) {
            this.currentFrame = frame;

            this.config.progressiveLoader && this.targetFrameDraw(frame);
            !this.config.progressiveLoader && this.drawImage(frame);
        }
    }, {
        key: 'drawImage',
        value: function drawImage(id) {
            if (!this.images[id]) return;

            var r = this.config.hiDPI ? window.devicePixelRatio : 1;
            var cw = this.ctx.canvas.width / r;
            var ch = this.ctx.canvas.height / r;
            var ca = cw / ch;
            var img = this.images[id];
            var ia = img.width / img.height;
            var iw = void 0,
                ih = void 0;

            if (this.config.scaleMode == 'cover') {
                if (ca > ia) {
                    iw = cw;
                    ih = iw / ia;
                } else {
                    ih = ch;
                    iw = ih * ia;
                }
            } else if (this.config.scaleMode == 'contain') {
                if (ca < ia) {
                    iw = cw;
                    ih = iw / ia;
                } else {
                    ih = ch;
                    iw = ih * ia;
                }
            } else {
                //this.config.scaleMode == 'auto'
                iw = img.width;
                ih = img.height;
            }

            var ox = cw / 2 - iw / 2;
            var oy = ch / 2 - ih / 2;

            this.ctx.save();
            this.ctx.scale(r, r);
            this.ctx.clearRect(0, 0, cw, ch); // support for images with alpha
            this.ctx.drawImage(img, 0, 0, img.width, img.height, ~~ox, ~~oy, ~~iw, ~~ih);
            this.ctx.restore();
        }
    }, {
        key: 'size',
        value: function size(w, h) {
            var r = this.config.hiDPI ? window.devicePixelRatio : 1;
            var c = this.ctx.canvas;
            c.width = w * r;
            c.height = h * r;
            c.style.width = w + 'px';
            c.style.height = h + 'px';
            this.drawImage();
        }
    }, {
        key: 'parseSequence',
        value: function parseSequence(from, to) {
            var l = Math.min(from.length, to.length);
            var i = Math.max(0, from.lastIndexOf('/'));

            while (from.charAt(i) == to.charAt(i) && !/[1-9]/.test(from.charAt(i)) && i < l) {
                i++;
            }var a = from.slice(i, from.lastIndexOf('.')); // from, may contain leading zeros
            var b = to.slice(i, to.lastIndexOf('.')); // to
            var ia = parseInt(a);
            var ib = parseInt(b);

            return {
                from: ia,
                to: ib,
                base: from.substr(0, i),
                ext: from.substr(from.lastIndexOf('.')),
                zeroes: a.length == b.length && Math.floor(log10(ia)) < Math.floor(log10(ib)) ? a.length : 0,
                length: Math.abs(ib - ia) + 1
            };

            function log10(x) {
                return Math.log(x) / Math.LN10;
            }
        }
    }, {
        key: 'buildFileList',
        value: function buildFileList(sequenceObj) {
            var q = [];
            var dir = sequenceObj.from > sequenceObj.to ? -1 : 1;
            for (var i = 0; i < sequenceObj.length; i++) {
                var n = (sequenceObj.from + i * dir).toString();
                var num = padLeft(n, '0', sequenceObj.zeroes);
                q.push(sequenceObj.base + num + sequenceObj.ext);
            }
            return q;
        }
    }, {
        key: 'targetFrameDraw',
        value: function targetFrameDraw(targetFrame) {
            this.images[targetFrame] && this.drawImage(targetFrame);
            !this.images[targetFrame] && this.frameLoader(targetFrame, true);

            var _config2 = this.config,
                smoothFrameChange = _config2.smoothFrameChange,
                preloadFrameCount = _config2.preloadFrameCount,
                fps = _config2.fps;

            var preloadFrames = smoothFrameChange ? fps * 2 : preloadFrameCount;

            for (var i = -preloadFrames; i < preloadFrames; i++) {
                this.frameLoader(this.currentFrame + i);
            }
        }
    }, {
        key: 'frameLoader',
        value: function frameLoader(targetFrame) {
            var _this2 = this;

            var drawAfterLoad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            if (!this.fileList[targetFrame]) return;

            if (!this.images[targetFrame]) {
                var img = new Image();
                img.src = this.fileList[targetFrame];
                img.onload = drawAfterLoad ? function () {
                    _this2.drawImage(targetFrame);
                } : null;
                img.onerror = function () {
                    console.log('Error with image-id: ' + targetFrame);
                };
                this.images[targetFrame] = img;
            }
        }
    }, {
        key: 'preloader',
        value: function preloader() {
            var _this3 = this;

            var iterativeCount = [16, 8, 4, 2, 1];
            var firstLoadImageCount = this.config.preloadFrameCount;

            this.frameLoader(0, true);

            for (var firstImageCount = 1; firstImageCount <= firstLoadImageCount; firstImageCount++) {
                this.frameLoader(firstImageCount);

                if (firstImageCount === firstLoadImageCount) {
                    iterativeCount.forEach(function (currentCount) {
                        for (var current = 0; current < _this3.fileList.length; current += currentCount) {
                            _this3.frameLoader(current);
                        }
                    });
                }
            }
        }
    }]);

    return Sequencer;
}();

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['ScrollMagic'], factory);
    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
        // CommonJS
        factory(require('scrollmagic'));
    } else {
        // no browser global export needed, just execute
        factory(root.ScrollMagic || root.jQuery && root.jQuery.ScrollMagic);
    }
})(undefined, function (ScrollMagic) {
    // 'window' change to 'this'
    ScrollMagic.Scene.prototype.addImageSequencer = function (opt) {
        var _this4 = this;

        var sequencer = new Sequencer(opt);

        this.on('progress', function () {
            var currentFrame = Math.round(_this4.progress() * (sequencer.fileList.length - 1));
            sequencer.updateFrame(currentFrame);
        });
    };
});
