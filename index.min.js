'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Image Sequencer for ScrollMagic Scene
 * (c) 2018
 *
 * Author:
 *      Ilya Kiselev
 *      ikiselev1989@gmail.com
 *
 * Project:
 *      https://github.com/ikiselev1989/scrollmagic-image-sequencer-plugin
 *
 * Version: 3.2.0
 *
 * Based on http://github.com/ertdfgcvb/Sequencer
 */

String.prototype.repeat = String.prototype.repeat || function (n) {
    return n <= 1 ? this : this + this.repeat(n - 1);
};

function padLeft(str, char, length) {
    return char.repeat(Math.max(0, length - str.length)) + str;
}

var Sequencer = function () {
    function Sequencer(opts, scene) {
        var _this = this;

        _classCallCheck(this, Sequencer);

        var defaults = {
            canvas: null,
            from: '',
            to: '',
            asyncLoader: false,
            scaleMode: 'cover', // can be: auto, cover, contain
            hiDPI: true,
            initFrameDraw: true,
            durationMultiply: 4,
            totalLoadCallback: null,
            imageLoadCallback: null
        };

        this.scene = scene;
        this._config = Object.assign({}, defaults, opts);

        // backwards compatibility: .retina field is assigned to .hiDPI (Retina is an Apple trademark)
        if (opts.hasOwnProperty('retina')) this._config.hiDPI = opts.retina;

        if (this._config.from == '' && this._config.to == '') {
            console.error('Missing filenames.');
            return false;
        }

        if (!this._config.canvas) {
            console.error('Missing canvas node.');
            return false;
        }

        this._stoped = false;
        this._loadedImages = 0;
        this._totalLoaded = false;

        this._images = [];

        this._canvasInit();

        var sequenceParser = this._parseSequence(this._config.from, this._config.to);
        this._fileList = this._buildFileList(sequenceParser);

        if (this._config.durationMultiply <= 0) this._config.durationMultiply = 1;
        this.scene.duration(this._fileList.length * this._config.durationMultiply / 100 * document.documentElement.clientHeight);

        var init = function init(_ref) {
            var progress = _ref.progress;

            _this._sceneProgressInit(progress);
            _this.scene.off('progress', init);
        };

        this.scene.on('progress', init);
    }

    _createClass(Sequencer, [{
        key: '_canvasInit',
        value: function _canvasInit() {
            var tagName = this._config.canvas.tagName;


            if (tagName === 'CANVAS') {
                this._ctx = this._config.canvas.getContext('2d');
                this._size(this._ctx.canvas.width, this._ctx.canvas.height);
            } else if (tagName === 'IMG') {
                this._imgMode = true;
            } else {
                console.log('Wrong canvas node.');
            }
        }
    }, {
        key: '_sceneProgressInit',
        value: function _sceneProgressInit(progress) {
            this._currentFrame = Math.round(progress * (this._fileList.length - 1));
            this._preloader();

            this.scene.on('progress', this._progressor.bind(this));
        }
    }, {
        key: '_frameLoader',
        value: function _frameLoader(targetFrame) {
            var _this2 = this;

            if (this._images[targetFrame]) return;

            var img = new Image();

            img.onload = function () {
                img.loaded = true;

                _this2._loadedImages++;

                if (!_this2._config.asyncLoader) {
                    if (_this2._loadedImages < _this2._fileList.length) {
                        _this2._frameLoader(_this2._loadedImages);
                    }
                }

                if (_this2._config.initFrameDraw && targetFrame === _this2._currentFrame) {
                    !_this2._imgMode && _this2._canvasDraw();
                    _this2._imgMode && _this2._imageDraw();
                }

                _this2._config.imageLoadCallback && _this2._config.imageLoadCallback({ img: img, frame: targetFrame });

                if (_this2._loadedImages === _this2._fileList.length) {
                    _this2._loadedImagesCallback();
                }
            };

            img.onerror = function () {
                console.error('Error with image-id: ' + targetFrame);
            };

            this._images[targetFrame] = img;

            img.src = this._fileList[targetFrame];
        }
    }, {
        key: '_preloader',
        value: function _preloader() {
            this._frameLoader(this._currentFrame);

            if (this._config.asyncLoader) {
                for (var iter = 0; iter < this._fileList.length; iter++) {
                    this._frameLoader(iter);
                }
            }
        }
    }, {
        key: '_loadedImagesCallback',
        value: function _loadedImagesCallback() {
            this._totalLoaded = true;
            this._config.totalLoadCallback && this._config.totalLoadCallback();
        }
    }, {
        key: '_progressor',
        value: function _progressor(_ref2) {
            var progress = _ref2.progress;

            if (this._stoped) return;

            this._currentFrame = Math.round(progress * (this._fileList.length - 1));
            this._drawFrame();
        }
    }, {
        key: '_drawFrame',
        value: function _drawFrame() {
            !this._imgMode && requestAnimationFrame(this._canvasDraw.bind(this));
            this._imgMode && requestAnimationFrame(this._imageDraw.bind(this));
        }
    }, {
        key: '_canvasDraw',
        value: function _canvasDraw() {
            var img = this._images[this._currentFrame];

            if (!img || !img.loaded) return;

            var r = this._config.hiDPI ? window.devicePixelRatio : 1;
            var cw = this._ctx.canvas.width / r;
            var ch = this._ctx.canvas.height / r;
            var ca = cw / ch;
            var ia = img.width / img.height;
            var iw = void 0,
                ih = void 0;

            if (this._config.scaleMode == 'cover') {
                if (ca > ia) {
                    iw = cw;
                    ih = iw / ia;
                } else {
                    ih = ch;
                    iw = ih * ia;
                }
            } else if (this._config.scaleMode == 'contain') {
                if (ca < ia) {
                    iw = cw;
                    ih = iw / ia;
                } else {
                    ih = ch;
                    iw = ih * ia;
                }
            } else {
                //this._config.scaleMode == 'auto'
                iw = img.width;
                ih = img.height;
            }

            var ox = cw / 2 - iw / 2;
            var oy = ch / 2 - ih / 2;

            this._ctx.save();
            this._ctx.scale(r, r);
            this._ctx.clearRect(0, 0, cw, ch); // support for images with alpha
            this._ctx.drawImage(img, 0, 0, img.width, img.height, ~~ox, ~~oy, ~~iw, ~~ih);
            this._ctx.restore();

            this._currentDrawFrame = this._currentFrame;
        }
    }, {
        key: '_imageDraw',
        value: function _imageDraw() {
            var img = this._images[this._currentFrame];

            if (!img || !img.loaded) return;

            this._config.canvas.src = img.src;
        }
    }, {
        key: '_size',
        value: function _size(w, h) {
            var r = this._config.hiDPI ? window.devicePixelRatio : 1;
            var c = this._ctx.canvas;
            c.width = w * r;
            c.height = h * r;
            c.style.width = w + 'px';
            c.style.height = h + 'px';
        }
    }, {
        key: '_parseSequence',
        value: function _parseSequence(from, to) {
            var l = Math.min(from.length, to.length);
            var i = Math.max(0, from.lastIndexOf('/'));

            while (from.charAt(i) == to.charAt(i) && !/[1-9]/.test(from.charAt(i)) && i < l) {
                i++;
            }var a = from.slice(i, from.lastIndexOf('.')); // from, may contain leading zeros
            var b = to.slice(i, to.lastIndexOf('.')); // to
            var ia = parseInt(a);
            var ib = parseInt(b);

            return {
                from: ia,
                to: ib,
                base: from.substr(0, i),
                ext: from.substr(from.lastIndexOf('.')),
                zeroes: a.length == b.length && Math.floor(log10(ia)) < Math.floor(log10(ib)) ? a.length : 0,
                length: Math.abs(ib - ia) + 1
            };

            function log10(x) {
                return Math.log(x) / Math.LN10;
            }
        }
    }, {
        key: '_buildFileList',
        value: function _buildFileList(sequenceObj) {
            var q = [];
            var dir = sequenceObj.from > sequenceObj.to ? -1 : 1;
            for (var i = 0; i < sequenceObj.length; i++) {
                var n = (sequenceObj.from + i * dir).toString();
                var num = padLeft(n, '0', sequenceObj.zeroes);
                q.push(sequenceObj.base + num + sequenceObj.ext);
            }
            return q;
        }
    }, {
        key: 'resumeDrawing',
        value: function resumeDrawing() {
            this._stoped = false;
        }
    }, {
        key: 'stopDrawing',
        value: function stopDrawing() {
            this._stoped = true;
        }
    }, {
        key: 'resize',
        value: function resize(width, height) {
            if (!width || !height) {
                return console.error('resize "width" or "height" missed');
            }

            this._size(width, height);
            this._drawFrame();
        }
    }]);

    return Sequencer;
}();

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['ScrollMagic'], factory);
    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
        // CommonJS
        factory(require('scrollmagic'));
    } else {
        // no browser global export needed, just execute
        factory(root.ScrollMagic || root.jQuery && root.jQuery.ScrollMagic);
    }
})(undefined, function (ScrollMagic) {
    // 'window' change to 'this'
    ScrollMagic.Scene.prototype.addImageSequencer = function (opt) {
        return new Sequencer(opt, this);
    };
});
