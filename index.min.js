'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Image Sequencer for ScrollMagic Scene
 * (c) 2018
 *
 * Author:
 *      Ilya Kiselev
 *      ikiselev1989@gmail.com
 *
 * Project:
 *      https://github.com/ikiselev1989/scrollmagic-image-sequencer-plugin
 *
 * Based on http://github.com/ertdfgcvb/Sequencer
 */

String.prototype.repeat = String.prototype.repeat || function (n) {
    return n <= 1 ? this : this + this.repeat(n - 1);
};

function padLeft(str, char, length) {
    return char.repeat(Math.max(0, length - str.length)) + str;
}

var Sequencer = function () {
    function Sequencer(opts) {
        _classCallCheck(this, Sequencer);

        var defaults = {
            canvas: null,
            from: '',
            to: '',
            scaleMode: 'cover', // as in CSS3, can be: auto, cover, contain
            hiDPI: true
        };

        this.config = Object.assign({}, defaults, opts);

        // backwards compatibility: .retina field is assigned to .hiDPI (Retina is an Apple trademark)
        if (opts.hasOwnProperty('retina')) this.config.hiDPI = opts.retina;

        if (this.config.from == '' && this.config.to == '') {
            console.error('Missing filenames.');
            return false;
        }

        if (!this.config.canvas) {
            console.error('Missing canvas node.');
            return false;
        }

        this.current = -1;
        this.images = [];
        this.lastLoaded = -1;
        this.ctx = this.config.canvas.getContext('2d');

        var s = this.parseSequence(this.config.from, this.config.to);
        this.fileList = this.buildFileList(s);

        this.size(this.ctx.canvas.width, this.ctx.canvas.height);

        this.load();
    }

    _createClass(Sequencer, [{
        key: 'load',
        value: function load() {
            this.load = function () {
                console.log('load() can be called only once.');
            };

            this.preloader(this.images, this.fileList, this.config.imageLoad, this.config.queueComplete);
        }
    }, {
        key: 'nextImage',
        value: function nextImage() {
            this.drawImage(++this.current);
        }
    }, {
        key: 'prevImage',
        value: function prevImage() {
            this.drawImage(--this.current);
        }
    }, {
        key: 'scrollDrawImage',
        value: function scrollDrawImage(reqFrame) {
            var _this = this;

            var frame = reqFrame - this.current;

            for (var i = 0; i < Math.abs(frame); i++) {
                requestAnimationFrame(function () {
                    frame > 0 ? _this.nextImage() : _this.prevImage();
                });
            }
        }
    }, {
        key: 'drawImage',
        value: function drawImage(id) {
            if (id === undefined) id = this.current;
            if (id < 0 || id >= this.images.length) return;

            var r = this.config.hiDPI ? window.devicePixelRatio : 1;
            var cw = this.ctx.canvas.width / r;
            var ch = this.ctx.canvas.height / r;
            var ca = cw / ch;
            var img = this.images[id];
            var ia = img.width / img.height;
            var iw = void 0,
                ih = void 0;

            if (this.config.scaleMode == 'cover') {
                if (ca > ia) {
                    iw = cw;
                    ih = iw / ia;
                } else {
                    ih = ch;
                    iw = ih * ia;
                }
            } else if (this.config.scaleMode == 'contain') {
                if (ca < ia) {
                    iw = cw;
                    ih = iw / ia;
                } else {
                    ih = ch;
                    iw = ih * ia;
                }
            } else {
                //this.config.scaleMode == 'auto'
                iw = img.width;
                ih = img.height;
            }

            var ox = cw / 2 - iw / 2;
            var oy = ch / 2 - ih / 2;

            this.ctx.save();
            this.ctx.scale(r, r);
            this.ctx.clearRect(0, 0, cw, ch); // support for images with alpha
            this.ctx.drawImage(img, 0, 0, img.width, img.height, ~~ox, ~~oy, ~~iw, ~~ih);
            this.ctx.restore();
        }
    }, {
        key: 'size',
        value: function size(w, h) {
            var r = this.config.hiDPI ? window.devicePixelRatio : 1;
            var c = this.ctx.canvas;
            c.width = w * r;
            c.height = h * r;
            c.style.width = w + 'px';
            c.style.height = h + 'px';
            this.drawImage();
        }
    }, {
        key: 'parseSequence',
        value: function parseSequence(from, to) {
            var l = Math.min(from.length, to.length);
            var i = Math.max(0, from.lastIndexOf('/'));

            while (from.charAt(i) == to.charAt(i) && !/[1-9]/.test(from.charAt(i)) && i < l) {
                i++;
            }var a = from.slice(i, from.lastIndexOf('.')); // from, may contain leading zeros
            var b = to.slice(i, to.lastIndexOf('.')); // to
            var ia = parseInt(a);
            var ib = parseInt(b);

            return {
                from: ia,
                to: ib,
                base: from.substr(0, i),
                ext: from.substr(from.lastIndexOf('.')),
                zeroes: a.length == b.length && Math.floor(log10(ia)) < Math.floor(log10(ib)) ? a.length : 0,
                length: Math.abs(ib - ia) + 1
            };

            function log10(x) {
                return Math.log(x) / Math.LN10;
            }
        }
    }, {
        key: 'buildFileList',
        value: function buildFileList(sequenceObj) {
            var q = [];
            var dir = sequenceObj.from > sequenceObj.to ? -1 : 1;
            for (var i = 0; i < sequenceObj.length; i++) {
                var n = (sequenceObj.from + i * dir).toString();
                var num = padLeft(n, '0', sequenceObj.zeroes);
                q.push(sequenceObj.base + num + sequenceObj.ext);
            }
            return q;
        }
    }, {
        key: 'preloader',
        value: function preloader(arrayToPopulate, fileList, imageLoadCallback, queueCompleteCallbak) {
            var concurrentLoads = Math.min(fileList.length, 4);
            var current = arrayToPopulate.length - 1; // id: order in array
            var count = arrayToPopulate.length; // count: count of image loaded... can be out of sync of id.
            for (var i = 0; i < concurrentLoads; i++) {
                loadNext();
            }function loadNext() {
                if (current >= fileList.length - 1) return;
                current++;

                //console.log('Loading ' + fileList[current] + '...');
                var img = new Image();
                img.src = fileList[current];
                (function (id) {
                    img.onload = function (e) {
                        if (typeof imageLoadCallback === 'function') imageLoadCallback({
                            id: id,
                            img: img,
                            count: ++count,
                            total: fileList.length
                        });
                        if (count < fileList.length) {
                            loadNext();
                        }
                        if (count == fileList.length) {
                            if (typeof queueCompleteCallbak === 'function') queueCompleteCallbak({
                                total: fileList.length
                            });
                        }
                    };
                    img.onerror = function (e) {
                        console.error('Error with: ' + fileList[id]);
                    };
                })(current);
                arrayToPopulate.push(img);
            }
        }
    }]);

    return Sequencer;
}();

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['ScrollMagic'], factory);
    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
        // CommonJS
        factory(require('scrollmagic'));
    } else {
        // no browser global export needed, just execute
        factory(root.ScrollMagic || root.jQuery && root.jQuery.ScrollMagic);
    }
})(undefined, function (ScrollMagic) {
    // 'window' change to 'this'
    ScrollMagic.Scene.prototype.addImageSequencer = function (opt) {
        var _this2 = this;

        var sequencer = new Sequencer(opt);

        this.on('progress', function () {
            var currentFrame = Math.round(_this2.progress() * (sequencer.images.length - 1));
            sequencer.scrollDrawImage(currentFrame);
        });
    };
});
