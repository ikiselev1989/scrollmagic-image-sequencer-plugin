'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Image Sequencer for ScrollMagic Scene
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * (c) 2018
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Author:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *      Ilya Kiselev
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *      ikiselev1989@gmail.com
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Project:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *      https://github.com/ikiselev1989/scrollmagic-image-sequencer-plugin
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Version: 3.6.2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Based on http://github.com/ertdfgcvb/Sequencer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _webglUtils = require('./webgl-utils/webgl-utils');

var _webglUtils2 = _interopRequireDefault(_webglUtils);

var _m = require('./webgl-utils/m4');

var _m2 = _interopRequireDefault(_m);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

String.prototype.repeat = String.prototype.repeat || function (n) {
    return n <= 1 ? this : this + this.repeat(n - 1);
};

function padLeft(str, char, length) {
    return char.repeat(Math.max(0, length - str.length)) + str;
}

var Sequencer = function () {
    function Sequencer(opts, scene) {
        var _this = this;

        _classCallCheck(this, Sequencer);

        var defaults = {
            canvas: null,
            canvasContext: 'auto', // can be: auto, webgl, 2d
            from: '',
            to: '',
            asyncLoader: false,
            scaleMode: 'cover', // can be: auto, cover, contain
            framePosition: 'center center', // default: center center
            hiDPI: true,
            initFrameDraw: true,
            totalLoadCallback: null,
            imageLoadCallback: null
        };

        this.scene = scene;
        this._config = Object.assign({}, defaults, opts);

        // backwards compatibility: .retina field is assigned to .hiDPI (Retina is an Apple trademark)
        if (opts.hasOwnProperty('retina')) this._config.hiDPI = opts.retina;

        if (this._config.from == '' && this._config.to == '') {
            console.error('Missing filenames.');
            return false;
        }

        if (!this._config.canvas) {
            console.error('Missing canvas node.');
            return false;
        }

        this._stoped = false;
        this._loadedImages = 0;
        this._totalLoaded = false;
        this._preloadTotalLoaded = false;

        this._images = [];

        this._isWebGL = true;
        this._canvasInit();

        var sequenceParser = this._parseSequence(this._config.from, this._config.to);
        this._fileList = this._buildFileList(sequenceParser);

        if (this._config.asyncLoader && typeof this._config.asyncLoader === 'boolean') {
            this._config.asyncLoader = this._fileList.length;
        }

        var init = function init(progress) {
            _this._sceneProgressInit(progress);
        };

        init(this.scene.progress());
    }

    _createClass(Sequencer, [{
        key: '_webglInit',
        value: function _webglInit() {
            var _this2 = this;

            var program = _webglUtils2.default.createProgramFromScripts(this._ctx, [{
                src: 'attribute vec4 a_position;attribute vec2 a_texcoord;uniform mat4 u_matrix;uniform mat4 u_textureMatrix;varying vec2 v_texcoord;void main() {gl_Position = u_matrix * a_position;v_texcoord = (u_textureMatrix * vec4(a_texcoord, 0, 1)).xy;}',
                type: 'x-shader/x-vertex'
            }, {
                src: 'precision mediump float;varying vec2 v_texcoord;uniform sampler2D u_texture;void main() {gl_FragColor = texture2D(u_texture, v_texcoord);}',
                type: 'x-shader/x-fragment'
            }]);

            var positionLocation = this._ctx.getAttribLocation(program, 'a_position');
            var texcoordLocation = this._ctx.getAttribLocation(program, 'a_texcoord');
            var matrixLocation = this._ctx.getUniformLocation(program, 'u_matrix');
            var textureMatrixLocation = this._ctx.getUniformLocation(program, 'u_textureMatrix');
            var textureLocation = this._ctx.getUniformLocation(program, 'u_texture');

            var positionBuffer = this._ctx.createBuffer();

            this._ctx.bindBuffer(this._ctx.ARRAY_BUFFER, positionBuffer);

            var positions = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];

            this._ctx.bufferData(this._ctx.ARRAY_BUFFER, new Float32Array(positions), this._ctx.STATIC_DRAW);

            var texcoordBuffer = this._ctx.createBuffer();

            this._ctx.bindBuffer(this._ctx.ARRAY_BUFFER, texcoordBuffer);

            var texcoords = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];

            this._ctx.bufferData(this._ctx.ARRAY_BUFFER, new Float32Array(texcoords), this._ctx.STATIC_DRAW);

            this._ctx.drawImage = function (tex, srcX, srcY, srcWidth, srcHeight, dstX, dstY, dstWidth, dstHeight) {
                _this2._ctx.bindTexture(_this2._ctx.TEXTURE_2D, tex);
                _this2._ctx.useProgram(program);
                _this2._ctx.bindBuffer(_this2._ctx.ARRAY_BUFFER, positionBuffer);
                _this2._ctx.enableVertexAttribArray(positionLocation);
                _this2._ctx.vertexAttribPointer(positionLocation, 2, _this2._ctx.FLOAT, false, 0, 0);
                _this2._ctx.bindBuffer(_this2._ctx.ARRAY_BUFFER, texcoordBuffer);
                _this2._ctx.enableVertexAttribArray(texcoordLocation);
                _this2._ctx.vertexAttribPointer(texcoordLocation, 2, _this2._ctx.FLOAT, false, 0, 0);

                var matrix = _m2.default.orthographic(0, _this2._ctx.canvas.width, _this2._ctx.canvas.height, 0, -1, 1);

                matrix = _m2.default.translate(matrix, dstX, dstY, 0);
                matrix = _m2.default.scale(matrix, dstWidth, dstHeight, 1);

                _this2._ctx.uniformMatrix4fv(matrixLocation, false, matrix);

                var texMatrix = _m2.default.translation(srcX / srcWidth, srcY / srcHeight, 0);

                texMatrix = _m2.default.scale(texMatrix, 1, 1, 1);

                _this2._ctx.uniformMatrix4fv(textureMatrixLocation, false, texMatrix);
                _this2._ctx.uniform1i(textureLocation, 0);
                _this2._ctx.drawArrays(_this2._ctx.TRIANGLES, 0, 6);
            };
        }
    }, {
        key: '_canvasInit',
        value: function _canvasInit() {
            var tagName = this._config.canvas.tagName;


            if (tagName === 'CANVAS') {
                if (this._config.canvasContext === 'auto') {
                    this._ctx = this._config.canvas.getContext('webgl');

                    if (!this._ctx) {
                        this._isWebGL = false;

                        this._ctx = this._config.canvas.getContext('2d');
                        console.info('Scrollmagic sequencer use 2d context');
                    } else {
                        console.info('Scrollmagic sequencer use WebGL context');
                        this._webglInit();
                    }
                } else {
                    this._ctx = this._config.canvas.getContext(this._config.canvasContext);

                    if (this._config.canvasContext === '2d') {
                        this._isWebGL = false;
                        console.info('Scrollmagic sequencer use 2d context');
                    } else {
                        console.info('Scrollmagic sequencer use WebGL context');
                        this._webglInit();
                    }
                }

                this._size(this._ctx.canvas.width, this._ctx.canvas.height);
            } else if (tagName === 'IMG') {
                this._imgMode = true;
            } else {
                console.error('Wrong canvas node.');
            }
        }
    }, {
        key: '_sceneProgressInit',
        value: function _sceneProgressInit(progress) {
            this._currentFrame = Math.round(progress * (this._fileList.length - 1));
            this._preloader();

            this.scene.on('progress', this._progressor.bind(this));
        }
    }, {
        key: '_frameLoader',
        value: function _frameLoader(targetFramesList) {
            var _this3 = this;

            var promisesList = [];

            targetFramesList.forEach(function (frame) {
                if (_this3._images[frame]) return;

                var promise = new Promise(function (resolve, reject) {
                    var img = new Image();

                    img.onload = function () {
                        img.loaded = true;
                        _this3._loadedImages++;

                        if (_this3._config.initFrameDraw && frame === _this3._currentFrame) {
                            !_this3._imgMode && _this3._canvasDraw();
                            _this3._imgMode && _this3._imageDraw();
                        }

                        _this3._config.imageLoadCallback && _this3._config.imageLoadCallback({ img: img, frame: frame });

                        if (_this3._loadedImages === _this3._fileList.length) {
                            _this3._loadedImagesCallback();
                        }

                        resolve();
                    };

                    img.onerror = function () {
                        console.error('Error with image-id: ' + frame);

                        reject();
                    };

                    _this3._images[frame] = img;

                    img.src = _this3._fileList[frame];
                });

                promisesList.push(promise);
            });

            return Promise.all(promisesList);
        }
    }, {
        key: '_preloader',
        value: function _preloader() {
            var _this4 = this;

            this._frameLoader([this._currentFrame]).then(function () {
                if (_this4._config.asyncLoader) {
                    _this4._asyncLoader(_this4._currentFrame);
                } else {
                    _this4._syncLoader(_this4._currentFrame);
                }
            });
        }
    }, {
        key: '_asyncLoader',
        value: function _asyncLoader(initFrame) {
            var _this5 = this;

            if (this._loadedImages < this._fileList.length) {
                var chunkStartIndex = (this._loadedImages + initFrame) % this._fileList.length;
                var chunkEndIndex = chunkStartIndex + parseInt(this._config.asyncLoader);
                chunkEndIndex = chunkEndIndex > this._fileList.length ? this._fileList.length : chunkEndIndex;

                var chunkArray = [];

                for (var i = chunkStartIndex; i < chunkEndIndex; i++) {
                    chunkArray.push(i);
                }

                this._frameLoader(chunkArray).then(function () {
                    requestAnimationFrame(_this5._asyncLoader.bind(_this5, initFrame));
                });
            }
        }
    }, {
        key: '_syncLoader',
        value: function _syncLoader(initFrame) {
            var _this6 = this;

            if (this._loadedImages < this._fileList.length) {
                var currentIndex = (this._loadedImages + initFrame) % this._fileList.length;

                this._frameLoader([currentIndex]).then(function () {
                    requestAnimationFrame(_this6._syncLoader.bind(_this6, initFrame));
                });
            }
        }
    }, {
        key: '_loadedImagesCallback',
        value: function _loadedImagesCallback() {
            this._totalLoaded = true;
            this._config.totalLoadCallback && this._config.totalLoadCallback();
        }
    }, {
        key: '_progressor',
        value: function _progressor(_ref) {
            var progress = _ref.progress;

            if (this._stoped) return;

            this._currentFrame = Math.round(progress * (this._fileList.length - 1));
            this._drawFrame();
        }
    }, {
        key: '_drawFrame',
        value: function _drawFrame() {
            !this._imgMode && requestAnimationFrame(this._canvasDraw.bind(this));
            this._imgMode && requestAnimationFrame(this._imageDraw.bind(this));
        }
    }, {
        key: '_canvasDraw',
        value: function _canvasDraw() {
            var img = this._images[this._currentFrame];

            if (!img || !img.loaded) return;

            var r = this._config.hiDPI ? window.devicePixelRatio : 1;
            var cw = this._isWebGL ? this._ctx.canvas.width : this._ctx.canvas.width / r;
            var ch = this._isWebGL ? this._ctx.canvas.height : this._ctx.canvas.height / r;
            var ca = cw / ch;
            var ia = img.width / img.height;
            var iw = void 0,
                ih = void 0;

            var ox = null,
                oy = null;

            if (this._config.scaleMode == 'cover') {
                if (ca > ia) {
                    iw = cw;
                    ih = iw / ia;
                } else {
                    ih = ch;
                    iw = ih * ia;
                }

                var position = this._config.framePosition.split(' ');

                ox = position[0] === 'center' ? cw / 2 - iw / 2 : position[0] === 'left' ? 0 : cw - iw;
                oy = position[1] === 'center' ? ch / 2 - ih / 2 : position[1] === 'top' ? 0 : ch - ih;
            } else if (this._config.scaleMode == 'contain') {
                if (ca < ia) {
                    iw = cw;
                    ih = iw / ia;
                } else {
                    ih = ch;
                    iw = ih * ia;
                }
            } else {
                //this._config.scaleMode == 'auto'
                iw = img.width;
                ih = img.height;
            }

            ox = ox === null ? cw / 2 - iw / 2 : ox;
            oy = oy === null ? ch / 2 - ih / 2 : oy;

            if (this._isWebGL) {
                this._ctx.viewport(0, 0, this._ctx.canvas.width, this._ctx.canvas.height);

                this._ctx.clear(this._ctx.COLOR_BUFFER_BIT);

                var tex = this._ctx.createTexture();

                this._ctx.bindTexture(this._ctx.TEXTURE_2D, tex);
                this._ctx.texImage2D(this._ctx.TEXTURE_2D, 0, this._ctx.RGBA, 1, 1, 0, this._ctx.RGBA, this._ctx.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));

                this._ctx.texParameteri(this._ctx.TEXTURE_2D, this._ctx.TEXTURE_WRAP_S, this._ctx.CLAMP_TO_EDGE);
                this._ctx.texParameteri(this._ctx.TEXTURE_2D, this._ctx.TEXTURE_WRAP_T, this._ctx.CLAMP_TO_EDGE);
                this._ctx.texParameteri(this._ctx.TEXTURE_2D, this._ctx.TEXTURE_MIN_FILTER, this._ctx.LINEAR);

                this._ctx.bindTexture(this._ctx.TEXTURE_2D, tex);
                this._ctx.texImage2D(this._ctx.TEXTURE_2D, 0, this._ctx.RGBA, this._ctx.RGBA, this._ctx.UNSIGNED_BYTE, img);

                this._ctx.drawImage(tex, 0, 0, img.width, img.height, ~~ox, ~~oy, ~~iw, ~~ih);
            } else {
                this._ctx.save();
                this._ctx.scale(r, r);
                this._ctx.clearRect(0, 0, cw, ch); // support for images with alpha
                this._ctx.drawImage(img, 0, 0, img.width, img.height, ~~ox, ~~oy, ~~iw, ~~ih);
                this._ctx.restore();
            }

            this._currentDrawFrame = this._currentFrame;
        }
    }, {
        key: '_imageDraw',
        value: function _imageDraw() {
            var img = this._images[this._currentFrame];

            if (!img || !img.loaded) return;

            this._config.canvas.src = img.src;
        }
    }, {
        key: '_size',
        value: function _size(w, h) {
            var r = this._config.hiDPI ? window.devicePixelRatio : 1;
            var c = this._ctx.canvas;
            c.width = w * r;
            c.height = h * r;
            c.style.width = w + 'px';
            c.style.height = h + 'px';
        }
    }, {
        key: '_parseSequence',
        value: function _parseSequence(from, to) {
            var l = Math.min(from.length, to.length);
            var i = Math.max(0, from.lastIndexOf('/'));

            while (from.charAt(i) == to.charAt(i) && !/[1-9]/.test(from.charAt(i)) && i < l) {
                i++;
            }var a = from.slice(i, from.lastIndexOf('.')); // from, may contain leading zeros
            var b = to.slice(i, to.lastIndexOf('.')); // to
            var ia = parseInt(a);
            var ib = parseInt(b);

            return {
                from: ia,
                to: ib,
                base: from.substr(0, i),
                ext: from.substr(from.lastIndexOf('.')),
                zeroes: a.length == b.length && Math.floor(log10(ia)) < Math.floor(log10(ib)) ? a.length : 0,
                length: Math.abs(ib - ia) + 1
            };

            function log10(x) {
                return Math.log(x) / Math.LN10;
            }
        }
    }, {
        key: '_buildFileList',
        value: function _buildFileList(sequenceObj) {
            var q = [];
            var dir = sequenceObj.from > sequenceObj.to ? -1 : 1;
            for (var i = 0; i < sequenceObj.length; i++) {
                var n = (sequenceObj.from + i * dir).toString();
                var num = padLeft(n, '0', sequenceObj.zeroes);
                q.push(sequenceObj.base + num + sequenceObj.ext);
            }
            return q;
        }
    }, {
        key: 'resumeDrawing',
        value: function resumeDrawing() {
            this._stoped = false;
        }
    }, {
        key: 'stopDrawing',
        value: function stopDrawing() {
            this._stoped = true;
        }
    }, {
        key: 'resize',
        value: function resize(width, height) {
            if (!width || !height) {
                return console.error('resize "width" or "height" missed');
            }

            this._size(width, height);
            this._drawFrame();
        }
    }]);

    return Sequencer;
}();

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['ScrollMagic'], factory);
    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
        // CommonJS
        factory(require('scrollmagic'));
    } else {
        // no browser global export needed, just execute
        factory(root.ScrollMagic || root.jQuery && root.jQuery.ScrollMagic);
    }
})(undefined, function (ScrollMagic) {
    // 'window' change to 'this'
    ScrollMagic.Scene.prototype.addImageSequencer = function (opt) {
        return new Sequencer(opt, this);
    };
});
