'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * Image Sequencer for ScrollMagic Scene
 * (c) 2018
 *
 * Author:
 *      Ilya Kiselev
 *      ikiselev1989@gmail.com
 *
 * Project:
 *      https://github.com/ikiselev1989/scrollmagic-image-sequencer-plugin
 *
 * Version: 2.0.0
 *
 * Based on http://github.com/ertdfgcvb/Sequencer
 */

String.prototype.repeat = String.prototype.repeat || function (n) {
    return n <= 1 ? this : this + this.repeat(n - 1);
};

function padLeft(str, char, length) {
    return char.repeat(Math.max(0, length - str.length)) + str;
}

var Sequencer = function () {
    function Sequencer(opts) {
        _classCallCheck(this, Sequencer);

        var defaults = {
            canvas: null,
            from: '',
            to: '',
            scaleMode: 'cover', // can be: auto, cover, contain
            hiDPI: true,
            asyncLoader: false,
            fps: 60,
            timeDeltaFactor: 5,
            totalLoadCallback: null,
            imageLoadCallback: null
        };

        this.config = Object.assign({}, defaults, opts);

        // backwards compatibility: .retina field is assigned to .hiDPI (Retina is an Apple trademark)
        if (opts.hasOwnProperty('retina')) this.config.hiDPI = opts.retina;

        if (this.config.from == '' && this.config.to == '') {
            console.error('Missing filenames.');
            return false;
        }

        if (!this.config.canvas) {
            console.error('Missing canvas node.');
            return false;
        }

        this.direction = 'PAUSED';
        this.loadedImages = 0;
        this.totalLoaded = false;
        this.frameCountFactor = 1;

        this.asyncPreloaderList = [];

        this.stoped = true;
        this.currentFrame = 0;
        this.images = [];
        this.ctx = this.config.canvas.getContext('2d');

        var s = this.parseSequence(this.config.from, this.config.to);
        this.fileList = this.buildFileList(s);

        this.size(this.ctx.canvas.width, this.ctx.canvas.height);

        this.load();
    }

    _createClass(Sequencer, [{
        key: 'load',
        value: function load() {
            if (!this.config.asyncLoader) {
                this.preloader();
            }
        }
    }, {
        key: 'setDrawLoop',
        value: function setDrawLoop(currentFrame, direction) {
            var _this = this;

            this.clearDrawLoop();

            if (!this.config.asyncLoader && !this.totalLoaded) return;

            this.direction = direction;
            this.stoped = this.direction === 'PAUSED';

            var _config = this.config,
                fps = _config.fps,
                timeDeltaFactor = _config.timeDeltaFactor;

            var frameCount = Math.abs(this.currentFrame - currentFrame);
            var frameCountFactor = Math.round(frameCount / fps * timeDeltaFactor);

            this.frameCountFactor = frameCountFactor <= 1 ? 1 : frameCountFactor;

            this.drawLoop = setInterval(function () {

                _this.setCurrentFrameByDirection(_this.frameCountFactor);
                _this.loaderMethodChecker();

                frameCount -= _this.frameCountFactor;

                if (frameCount <= 0) {
                    clearInterval(_this.drawLoop);
                }
            }, 1000 / fps);
        }
    }, {
        key: 'clearDrawLoop',
        value: function clearDrawLoop() {
            clearInterval(this.drawLoop);
            clearTimeout(this.drawLoopTimeout);
        }
    }, {
        key: 'setCurrentFrameByDirection',
        value: function setCurrentFrameByDirection() {
            var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

            if (this.direction === 'FORWARD') this.currentFrame += factor;
            if (this.direction === 'REVERSE') this.currentFrame -= factor;

            var imagesCount = this.fileList.length - 1;
            this.currentFrame = this.currentFrame < 0 ? 0 : this.currentFrame > imagesCount ? imagesCount : this.currentFrame;
        }
    }, {
        key: 'loaderMethodChecker',
        value: function loaderMethodChecker() {
            this.config.asyncLoader && this.asyncLoadedChecker();
            !this.config.asyncLoader && this.drawImage();
        }
    }, {
        key: 'asyncLoadedChecker',
        value: function asyncLoadedChecker() {
            var image = this.images[this.currentFrame];

            image && image.loaded && this.drawImage();
            !image && this.frameLoader(this.currentFrame);

            if (!this.totalLoaded) {
                this.asyncPreloader();
            }
        }
    }, {
        key: 'frameLoader',
        value: function frameLoader(targetFrame) {
            var _this2 = this;

            if (this.images[targetFrame]) return;

            var img = new Image();

            img.onload = function () {
                img.loaded = true;

                _this2.loadedImages++;

                _this2.config.asyncLoader && _this2.stoped && _this2.drawImage();
                _this2.config.imageLoadCallback && _this2.config.imageLoadCallback({ img: img, frame: targetFrame });

                if (_this2.loadedImages === _this2.fileList.length) {
                    _this2.loadedImagesCallback();
                }
            };

            img.onerror = function () {
                console.error('Error with image-id: ' + targetFrame);
            };

            this.images[targetFrame] = img;

            img.src = this.fileList[targetFrame];
        }
    }, {
        key: 'asyncPreloader',
        value: function asyncPreloader() {
            var _this3 = this;

            var fps = this.config.fps;


            var preloadFrames = 5;
            var framesList = [];

            clearInterval(this.asyncPreloadInterval);

            for (var iter = 1; iter < preloadFrames; iter++) {
                if (this.currentFrame === 0) {
                    this.direction = 'FORWARD';
                }
                if (this.currentFrame === this.fileList.length - 1) {
                    this.direction = 'REVERSE';
                }

                var preloadFrame = this.direction === 'REVERSE' ? this.currentFrame - iter : this.currentFrame + iter;

                if (preloadFrame < 0 || preloadFrame >= this.fileList.length) {
                    return;
                }

                framesList.push(preloadFrame);
            }

            this.asyncPreloaderList = [].concat(framesList, _toConsumableArray(this.asyncPreloaderList));

            this.asyncPreloadInterval = setInterval(function () {
                var image = _this3.asyncPreloaderList.shift();

                if (!image) {
                    return clearInterval(_this3.asyncPreloadInterval);
                }

                _this3.frameLoader(image);
            }, 1000 / fps / 2);
        }
    }, {
        key: 'preloader',
        value: function preloader() {
            for (var iter = 0; iter < this.fileList.length; iter++) {
                this.frameLoader(iter);
            }
        }
    }, {
        key: 'loadedImagesCallback',
        value: function loadedImagesCallback() {
            this.totalLoaded = true;
            this.config.totalLoadCallback && this.config.totalLoadCallback();
            this.drawImage();
        }
    }, {
        key: 'drawImage',
        value: function drawImage() {
            requestAnimationFrame(this.canvasDraw.bind(this));
        }
    }, {
        key: 'canvasDraw',
        value: function canvasDraw() {
            var img = this.images[this.currentFrame];

            if (!img || !img.loaded || this.currentDrawFrame === this.currentFrame) return;

            var r = this.config.hiDPI ? window.devicePixelRatio : 1;
            var cw = this.ctx.canvas.width / r;
            var ch = this.ctx.canvas.height / r;
            var ca = cw / ch;
            var ia = img.width / img.height;
            var iw = void 0,
                ih = void 0;

            if (this.config.scaleMode == 'cover') {
                if (ca > ia) {
                    iw = cw;
                    ih = iw / ia;
                } else {
                    ih = ch;
                    iw = ih * ia;
                }
            } else if (this.config.scaleMode == 'contain') {
                if (ca < ia) {
                    iw = cw;
                    ih = iw / ia;
                } else {
                    ih = ch;
                    iw = ih * ia;
                }
            } else {
                //this.config.scaleMode == 'auto'
                iw = img.width;
                ih = img.height;
            }

            var ox = cw / 2 - iw / 2;
            var oy = ch / 2 - ih / 2;

            this.ctx.save();
            this.ctx.scale(r, r);
            this.ctx.clearRect(0, 0, cw, ch); // support for images with alpha
            this.ctx.drawImage(img, 0, 0, img.width, img.height, ~~ox, ~~oy, ~~iw, ~~ih);
            this.ctx.restore();

            this.currentDrawFrame = this.currentFrame;
        }
    }, {
        key: 'size',
        value: function size(w, h) {
            var r = this.config.hiDPI ? window.devicePixelRatio : 1;
            var c = this.ctx.canvas;
            c.width = w * r;
            c.height = h * r;
            c.style.width = w + 'px';
            c.style.height = h + 'px';
        }
    }, {
        key: 'parseSequence',
        value: function parseSequence(from, to) {
            var l = Math.min(from.length, to.length);
            var i = Math.max(0, from.lastIndexOf('/'));

            while (from.charAt(i) == to.charAt(i) && !/[1-9]/.test(from.charAt(i)) && i < l) {
                i++;
            }var a = from.slice(i, from.lastIndexOf('.')); // from, may contain leading zeros
            var b = to.slice(i, to.lastIndexOf('.')); // to
            var ia = parseInt(a);
            var ib = parseInt(b);

            return {
                from: ia,
                to: ib,
                base: from.substr(0, i),
                ext: from.substr(from.lastIndexOf('.')),
                zeroes: a.length == b.length && Math.floor(log10(ia)) < Math.floor(log10(ib)) ? a.length : 0,
                length: Math.abs(ib - ia) + 1
            };

            function log10(x) {
                return Math.log(x) / Math.LN10;
            }
        }
    }, {
        key: 'buildFileList',
        value: function buildFileList(sequenceObj) {
            var q = [];
            var dir = sequenceObj.from > sequenceObj.to ? -1 : 1;
            for (var i = 0; i < sequenceObj.length; i++) {
                var n = (sequenceObj.from + i * dir).toString();
                var num = padLeft(n, '0', sequenceObj.zeroes);
                q.push(sequenceObj.base + num + sequenceObj.ext);
            }
            return q;
        }
    }]);

    return Sequencer;
}();

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['ScrollMagic'], factory);
    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
        // CommonJS
        factory(require('scrollmagic'));
    } else {
        // no browser global export needed, just execute
        factory(root.ScrollMagic || root.jQuery && root.jQuery.ScrollMagic);
    }
})(undefined, function (ScrollMagic) {
    // 'window' change to 'this'
    ScrollMagic.Scene.prototype.addImageSequencer = function (opt) {
        var sequencer = new Sequencer(opt);

        this.on('progress', function (_ref) {
            var progress = _ref.progress,
                scrollDirection = _ref.scrollDirection;

            var currentFrame = Math.round(progress * (sequencer.fileList.length - 1));
            sequencer.setDrawLoop(currentFrame, scrollDirection);
        });
    };
});
